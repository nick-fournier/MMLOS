---
title: "MMLOS usage"
author: "Nick Fournier, PhD"
date: "8/10/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(knitr)
library(data.table)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_knit$set(root.dir = "../")
```

### R Markdown

This is a vignette going through a simple example use of **MMLOS**, the Multi-Modal Level of Service calculator from the Highway Capacity Manual in *R*. In this vignette we will go over basic usage of MMLOS for calculating the LOS of links, intersections, and segments for bicycles and pedestrians (automobiles and transit to be implemented in future versions). This includes loading the link and intersection data from CSV and the proper data format of the CSV data. We will also do a bit of plotting the results, and comparing the results from the existing HCM methodology to our proposed revisions.


### Data formatting

Let's begin with with a [description of data](https://github.com/nick-fournier/MMLOS/blob/master/data/input_link_template.csv), shown below. There are two CSV files, one for links and one for segments. Templates can be found at [data/input_intersection_template.csv](https://github.com/nick-fournier/MMLOS/blob/master/data/input_intersection_template.csv) and [data/input_link_template.csv](https://github.com/nick-fournier/MMLOS/blob/master/data/input_link_template.csv). These templates are based on data collected along Hearst Avenue, a site where complete streets improvements were recently made.


```{r link description, echo = F} 
dat = fread("./data/input_descriptions.csv")[TYPE == "LINK", .(VAR,DESC)]
dat = setNames(dat, c("Variable","Description"))
kable(dat, caption = "Link data format:")
```

```{r int description, echo = F} 
dat = fread("./data/input_descriptions.csv")[TYPE == "INT", .(VAR,DESC)]
dat = setNames(dat, c("Variable","Description"))
kable(dat, caption = "Intersection data format:")
```

### General Usage

First install, if you haven't already, and load the package. MMLOS includes the dependency [data.table"](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html), which provides efficient data handling functions coded in C++, offering a much faster alternative to base-*R* data frames.

```{r libload} 
# #Install the MMLOS package (commented out to avoid errors)
# library(devtools)
# install_github("nick-fournier/MMLOS")

#Activate the installed package.
library(MMLOS)
```

After roadway data has been properly formatted into the **link** and **intersection** CSV files, they can be imported to *R*. The **dirs** parameter is a string vector with the two file locations. If left empty, a GUI prompt will pop up. Otherwise if "template" is entered, it'll just use the template files I have provided. For now we'll just use the template data.

```{r loaddat}
dat <- loaddat("template")
```

We can take a peak at this. Note the NA's in this example are because some intersections are only three-ways, so one approach is missing.

```{r head}
lapply(loaddat("template"),function(x) head(x,8))
```

Now we can calculate the LOS. The "existing" result uses the current HCM methodology, and the "revised" result uses the proposed revisions. Let's display what the results look like for the existing methodology. The results have a list of data tables for each mode.

```{r calc MMLOS}
existing <- calcMMLOS(dat, revs = F)
revised <- calcMMLOS(dat, revs = T)

#Display results
print(existing)

```

The results can be exported to a CSV by using the command:

```{r eval=FALSE}
fwrite(existing, "./some output folder/existing LOS.csv")

fwrite(revised, "./some output folder/revised LOS.csv")
```

## Existing versus revised HCM methodology

Alright now lets compare the results a bit for bikes. Basically what I am doing here is combining the two results into a single data table and formatting it to be plotted. 

```{r merge score} 
# Add a new column with the methodology version
# This is data.table syntax for assigning to a column.
existing[['bike']][ , method := "Existing"]
revised[['bike']][ , method := "Revised"]

# Add row number, help us to sort it later
existing[['bike']]$rn <- 1:nrow(existing[['bike']])
revised[['bike']]$rn <- 1:nrow(existing[['ped']])

# Combine the data tables vertically (stacking rows). Vertical format makes plotting easier
bike.scores <- rbind(existing[['bike']], revised[['bike']])

# Let's create a new unique ID column that contains the segment ID, direction, and methodology version
bike.scores[ , id := paste(segment_id, direction, method)]

#Re-shape the data from wide into long format. This is for the numeric scores
bike.scores <- melt(bike.scores[ , .(id, rn, method, I_int, I_link, I_seg)], id.vars = c("id","rn","method"))

#Sort data
bike.scores <- bike.scores[order(rn), ]

```

In general we can see that the revised version tends to have higher (worse) LOS score at intersections. This is because it now accounts for additional bicycle delay. We can also see that a few links (i.e., westbound Shattuck-Walnut, eastbound Spruce-Arch/Le Conte, and westbound Walnut-Oxford) had a reduced LOS score. This reduced LOS score is due to the revised LOS methodology accounting for separated bike lanes, specifically parking protected lanes that provide vertical separation. 

```{r plot compare}
#Plot
ggplot(data = bike.scores, aes(x = id, y = value, fill = variable, alpha = method)) + 
  geom_col(position = "dodge") +
  scale_fill_brewer("LOS component", palette = "Set1") +
  scale_alpha_discrete("Methodology", range = c(0.5,1)) +
  labs(x = NULL, y = "LOS Score") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```

The numeric scores then translate to letter grades, let's see how they compare. First we subset the letter grades in each result and combine them into a table. Although the row order is already sorted in each table, I like to use the merge command to ensure that nothing becomes mixed up. I then add the suffixed of " Existing" and " Revised" to distinguish the columns from each other.

```{r score table}
# Combine the data tables horizontally (add columns).
# We select only the letter grade columns
bike.grade <- merge(existing[['bike']][ , .(segment_id,direction, link_LOS, int_LOS, seg_LOS)],
      revised[['bike']][ , .(segment_id,direction, link_LOS, int_LOS, seg_LOS)],
      by = c("segment_id","direction"),
      suffixes = c(" Existing"," Revised"))

#Sort columns to my liking
bike.grade <- bike.grade[ , c(1:2,order(colnames(bike.grade)[-(1:2)])+2), with = F]

```

The resulting table generally reflects what we saw in the above plot.

```{r table, echo = FALSE}
kable(bike.grade)
```



